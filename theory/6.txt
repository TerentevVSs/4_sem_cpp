                синхронизация
1. конкуренция за владение общим ресурсом
    терминология:
        состояние гонки race condition
    решение проблемы:
        [0,1] - выключатель или табличка
        [vacant, closed]
        std::mutex
        mutex exclusion
            .lock()
            .unlock()
2. Тупик dead lock - если 2 или более mutex
    потоки блокируют друг друга
    пример, случается если 2 mutex блокируются в разном порядке
    решение: std::lock - следит чтобы не заблочили друг друга
        std::lock до c++17
        класс std::scoped_lock c c++17
        RAII - resource allocation is initialization
        std::unique_lock()
        копилка (из документации)
            1 переменная
            функция transfer 1 копилка => 2 копилка
            unique_block(std::mutex, std::defer_lock)
            std::defer_lock - не забирает mutex сразу
3. Сложение не в 1 действие
    каждому процессу соответствует областт памяти - stack
    ячейки памяти с которыми процессор может совершать операции - регистры
    "+" состоит из 3-х действий:
        1. скопировать в регистр
        2. сложить
        3. скопировать обратно
4. Атомарная переменная
    Действие, которое на уровне процессора выполняется за 1 действие - атомарное действие
    Переменная действия с которыми являются атомарными - атомарная переменная
    // операция выглядит снаружи как атомарная
    <atomic>:
        atomic<T> a1;
5. classic example
Гранулярность(крупная/мелкая) - оценка количества действий, являющихся потокобезопасными
5.1 мелкая
    for{
        ...
        действия
        ...

        .lock()
        обращение к общему ресурсу
        .unlock()

        действия
    }
5.2 крупная
    .lock()
    for{
        ...
    }
    .unlock()
6. RAII
{
    RAII - обертка для mutex
    действия
}
lock_guard
7. stack
    адаптер контейнера
    LIFO
    .push(elem)
    .top() -> elem
    .pop()